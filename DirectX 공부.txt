Chapter 4
Direct3D 초기화

*목표
 1. 3차원 그리팩 하드웨어의 프로그래밍에서 Direct3D의 역할을 개괄적으로 이해한다.
 2. Direct3D에서 COM의 역할을 이해한다.
 3. 2차원 이미지의 저장방식, 페이지 전환, 깊이 버퍼링, 다중 표본화 같은 기초 그래픽 개념들을 배운다.
 4. 성능 카운터 함수들을 이용해서 고해상도 타이머 값을 얻는 방법을 배운다.
 5. Direct3D를 초기화하는 방법을 파악한다.
 6. 이 책의 모든 예제프로그램이 사용하는 응용 프로그램 프레임워크의 전반적인 구조를 숙지한다.


4.1.1 Direct3D의 개요
 Direct3D : 응용프로그램에서 GPU를 제어하고 프로그래밍하는 데 쓰이는 저수준 그래픽 API이다.

4.1.2 COM
 COM : DirectX의 프로그래밍 언어 독립성과 호환성을 가능하게 하는 기술 ( COM객체를 C++ 클래스로 간주하고 사용해도 무방하다. )

 필요한 COM 인터페이스를 가리키는 포인터를 특별한 함수들을 이용해서, 또는 다른 COM 인터페이스의 메서드를 이용해서 얻는 방법뿐이다.
 
 ComPtr의 여러 메서드 중 중요한 3가지
  1. Get : 바탕 COM 인터페이스를 가리키는 포인터를 돌려준다. 해당 COM 인터페이스 포인터 형식의 인수를 받는 함수를 호출할 때 흔히 쓰인다.
  2. GetAddressOf : 바탕 COM 인터페이스를 가리키는 포인터의 주소를 돌려준다. 함수 매개변수를 통해서 COM 인터페이스 포인터*를 돌려받을 때 흔히 쓰인다.
  3. Reset : ComPtr 인스턴스를 nullptr로 설정하고 바탕 COM 인터페이스의 참조 횟수를 1 감소한다. 
	이 메서드를 사용하는 대신 ComPtr 인스턴스에 직접 nullptr를 배정해도 된다. ( 역시 참조 횟수가 감소한다. )ef
  - 참고 : COM 인터페이스들은 이름이 대문자 I로 시작한다

4.1.3 텍스처 형식
 텍스처 : 보통 3D 물체를 감싸는 2차원 이미지이러한 이미지 형식의 텍스처는 2차원 배열 형식으로 제공되며, 각 원소에 대응하는 픽셀들의 색상 정보가 들어갈 수 있다. 
	하지만 텍스처는 단지 이것만 가리키는 말이 아니다. 예를 들어 법선 매핑이라고 하는 고급 기법에서는 각 원소가 색상 정보가 아닌 3차원 벡터를 담는다. 
	어떤 텍스처는 형식이 없는 데이터를 담아서, 이후 파이프라인에서 정의하여 사용하는 경우도 있다. 텍스쳐의 형식 또한 단지 배열 뿐만이 아닌, 
	밉맵 수준들이 존재하는 텍스처, 또는 GPU에서는 필터링이나 다중 표본화와 같은 연산에도 텍스처를 적용할 수도 있다.

4.1.4 SwapChain과 페이지 전환
 제시(presenting) : 전면 버퍼와 후면버퍼의 역할을 교환해서 페이지가 전환되게 하는것. 버퍼의 내용 자체를 맞바꾸는게 아니라 포인터만 맞바꾼다.
 - 참고 : 텍스처의 원소를 텍셀(texel)이라고 부른다.

4.1.5 깊이버퍼 : 이미지 자료를 담지않는 텍스처의 한 예이다. 각 픽셀의 깊이 정보를 담는다. 
		픽셀의 깊이는 0.0에서 1.0까지의 값으로 0.0은 최대한 가까운 물체에 해당하고 1.0은 최대한 먼 물체에 해당한다.
		깊이 버퍼의 원소들과 후면 버퍼의 원소들은 일대일로 대응된다. 깊이 버퍼링을 이용하면 물체들을 그리는 순서와 무관하게 물체들이 제대로 가려진다.

4.1.6 자원과 서술자 
 렌더링 과정에서 GPU는 자원들에 자료를 기록하거나 (ex.후면버퍼나 깊이 스텐실 버퍼가 자원) 자원들에서 자료를 읽어 들인다.
 GPU 자원들이 파이프라인에 직접 묶이는(bind) 것은 아니다. 실제로 파이프라인에 묶이는 것은 해당 자원을 참조하는 서술자(descripter) 객체이다.
 서술자 객체 : 자원을 GPU에게 서술해주는 경량의 자료구조. 본질적으로 하나의 간접층이다.
 GPU는 자원 서술자를 통해서 자원의 실제 자료에 접근하며, 그 자료를 사용하는 데 필요한 정보 역시 자원 서술자로 부터 얻는다.
 그리기 호출이 참조할 서술자들을 명시하면 해당 자원들이 렌더링 파이프라인에 묶인다.

 서술자 : 자원 자료를 지정하는 수단일 뿐만 아니라, 자원을 GPU에 서술하는 수단.
	 Direct3D에게 자원의 사용법을(자원을 파이프라인의 어떤 단계에 묶어야 하는지를) 말해준다. 가능한 경우에는 파이프라인에 묶을 자원의 부분 영역을 서술자로 지정할 수 있다.

Direct3D 파이프라인
 *입력 조립 단계
  - 정점 버퍼의 정점데이터(프리미티브 데이터: 점, 선, 삼각형)를 다른 파이프라인 단계에서 사용할 
    프리미티브(선 리스트, 삼각형 리스트, 삼각형 스트립, 인접성을 가지는 프리미티브 등)로 조립하고
    시스템 생성 값을 추가하여 정점-쉐이더로 출력

 *래스터라이저 단계 
  - 벡터 정보(프리미티브)를 래스터 이미지(픽셀)로 변환 래스터라이제이션
  - 래스터라이제이션을 하는 동안 각 프리미티브를 구성하는 정점은 픽셀로 변환
  - 래스터라이저 단계
    * 원근 투영 나누기(z 나누기)
    * 카메라 절두체를 벗어나는 점(픽셀)들을 클리핑(Clipping)
    * 프리미티브를 2차원 뷰포트로 매핑
    * 프리미티브의 모든 픽셀들에 대하여 필셀-쉐이더를 호출
  * 래스터라이저 단계에서 픽셀의 속성 계산
   - 보간 : 선형보간, ...
   - 픽셀의 색상 보간
   - 다른 데이터(법선 벡터, 텍스쳐 좌표 등)도 보간
  - 요약 : 프리미티브를 구성하는 각 픽셀에 대한 연산을 수행하고 깊이값을 출력
 
 *출력 병합 단계
  - 최종적으로 픽셀의 색상을 생성하여 렌터 타겟으로 출력하는 단계
    파이프라인 상태 정보, 픽셀 쉐이더가 생성한 픽셀 색상, 렌더 타겟의 내용,
    그리고 깊이/스텐실 버퍼의 내용들을 조합하여 출력할 색상을 결정함
  - 깊이-스텐실 검사
   * 픽셀이 그려져야 하는지를 결정하기 위하여 깊이 값과 스텐실 값 데이터를 사용
   * 깊이 검사
     z = min(Viewport.MaxDepth, max(Viewport.MinDepth, z))
     출력 픽셀의 깊이 값을 깊이 버퍼의 같은 위치의 깊이 값과 비교
     비교의 결과에 따라 출력 픽셀을 렌더 타게에 출력하거나 출력하지 않음
   * 하나의 깊이/스텐실 버퍼만 활성화됨
   * 깊이-스텐실 버퍼에 스텐실 요소가 없으면 스텐실 검사는 항상 성공함
     깊이-스텐실 버퍼가 파이프라인에 연결되지 않으면 스텐실 검사는 항상 성공함
  - 블렌딩(Blending)
   * 픽셀 값(색상)들을 결합(블렌딩)하여 하나의 최종 픽셀 색상을 생성하는 과정임
   * 렌더 타겟의 픽셀 색상과 출력(픽셀 쉐이더) 색상을 결합
  -요약 : 각 픽셀에 대한 깊이-스텐실 검사와 블렌딩 연산을 수행하여 최종 출력 색상을 결정
 
 *정점 쉐이더 단계
  - 입력 조립 단계에서 출력되는 프리미티브의 각 정점에 대한 연산을 수행
    변환, 스키닝, Morphing, 조명
  - 정점 쉐이더는 하나의 정점에 대하여 한번 호출되며 하나의 출력 정점을 생성
  - 정점 쉐이더 단계는 파이프라인 단계에서 항상 수행되어야 함
    정점에 대한 변환이 필요하지 않더라도 정점-쉐이더를 생성하여 연결해야 함
  - 정점 쉐이더는 최소 하나의 입력과 하나의 출력을 가져야 함
  - 정점 쉐이더의 입력 정점은 16개의 32-비트 벡터(4-요소 벡터)까지 구성 가능
  - 정점 쉐이더의 출력 정점은 16개의 32-비트 벡터(4-요소 벡터)까지 구성 가능
  - 입력 조립 단계에서 생성한 두 개의 시스템 생성 시멘틱을 사용할 수 있음
    * SV_VertexID
    * SV_InstanceID
  - 정점 쉐이더는 항상 모든 정점들에 대하여 한번씩 실행됨
    정점 버퍼, 상수 변수, 버퍼, 텍스쳐 등의 데이터를 사용항 정점에 대한 연산을 수행
    인접 정점을 가진 입력 프리미티브의 경우 인접한 정점을 포함하여 실행됨
  - 정점-쉐이더는 텍스쳐 로드와 샘플링 연산을 수행할 수 있음
  - 요약 : 각 정점에 대한 연산을 수행 최소 하나의 입력과 출력을 가짐

 *픽셀 쉐이더 단계
  - 각 필셀의 데이터(기본적으로 색상) 생성
    상수 변수, 텍스쳐 데이터, 또는 픽셀 출력 데이터 등을 결합하여 출력 색상을 결정
    픽셀 쉐이더 단계에서 픽셀 조명 계산 또는 픽셀에 대한 후처리를 할 수 있음
  - 하나의 프리미티브를 구성하는 각 픽셀에 대하여 픽셀 쉐이더를 한번씩 호출함
    다중 샘플링을 사용하면 깊이/스텐실 테스트는 각 서브픽셀에 대하여 한번씩 수행
    다중 샘플링을 사용해도 픽셀 쉐이더는 하나의 픽셀에 대하여 한번만 호출됨
  - 기하 쉐이더 단계가 없으면 픽셀 쉐이더의 입력은 16개의 32-비트 벡터로 제한됨
    기하 쉐이더 단계를 사용하면 32개의 32-비트 벡터를 입력으로 사용할 수 있음
    픽셀 쉐이더 입력 데이터는 정점 속성을 포함하거나 프리미티브 상수가 될 수 있음
    픽셀의 정점 속성은 프리미티브의 정점 속성으로부터 보간됨(래스터라이저 단계)
  - 픽셀 쉐이더 입력은 시스템-값 시멘틱으로 선언(예: 픽셀 위치는 SV_Position)
    입력 조립 단계는 픽셀 쉐이더를 위해 SV_PrimitiveID 시멘틱을 생성
    래스터라이저 단계는 SV_IsFrontFace 시멘틱을 생성
  - 픽셀 쉐이더는 8개의 32-비트 4-요소 색상을 출력할 수 있음
    픽셀읠 버리면(discard) 색상과 깊이값이 출력되지 않음
    출력 병합 단계에서 깊이 버퍼에 깊이 데이터가 쓰여지는 것을 제어할 수 있음
    픽셀 쉐이더는 깊이 값 검사를 위하여 깊이값(SV_Depth 시멘틱)을 출력할 수 있음
    픽셀 쉐이더는 스텐실 값을 출력할 수 없음
  - 요약 : 프리미티브를 구성하는 각 픽셀에 대한 연산을 수행하고 깊이 값을 출력

 *시멘틱
  - 시멘틱은 쉐이더의 입력 또는 출력 파라미터 변수에 부착되는 문자열
    변수의 사용 의도를 나타내는 정보를 컴파일러에게 전달하기 위하여 사용
    쉐이더 컴파일러는 이 문자열을 쉐이더의 입력과 출력을 연결하기 위해 사용
    쉐이더 단계들 사이에서 전달되는 모든 변수에 시멘틱을 사용해야 함
  - 일반적으로 파이프라인 단계에서 전달되는 데이터는 고정된 의미를 갖지는 않음
    임의의 시멘틱이 허용됨
    시스템-값 시멘틱: 특별한 의미를 갖는 시멘틱
  - 쉐이더 변수 이름 다음에 콜론(:)과 시멘틱 문자열을 추가함
    쉐이더 프로그램의 전역변수와 파라미터 변수에만 시멘틱을 사용해야 함
    쉐이더 쉐이더 컴파일러는 다른 변수의 시멘틱은 무시함

 * Direct3D 리소스
  - 게임 월드를 구성하고 그리기 위해서는 여러 가지 형태의 데이터가 필요함
    데이터는 기하학적 데이터(정점 데이터), 텍스처, 쉐이더 데이터 등을 포함함
    파이프라인에서 효율적으로 참조할 수 있는 메모리 영역에 저장되어야 함
    데이터는 미리 작성된 것(파일)을 로드하거나 실행 시에 동적으로 생성할 수 있음
    일반적으로 데이터를 응용 프로그램(CPU)에서 생성하고 GPU에서 사용함

  - Direct3D는 리소스라는 개념고 이와 관련된 인터페이스를 제공함
    리소스는 Direct3D 파이프라인에서 사용할 수 있는 메모리의 영역임
    리소스는 최적의 성능을 위해서 가능하다면 비디오 메모리에 존재해야 함
    리소스는 GPU가 효율적으로 읽기/쓰기가 가능해야 함
    기하학적 데이터, 텍스쳐, 쉐이더 데이터 등은 리소스로 저장되어야 함
    모든 Direct3D 리소스는 버퍼 또는 텍스처 형식을 가짐
    리소스는 데이터 타입, 읽기 속성, 쓰기 속성을 지정할 수 있음
    리소스는 CPU와 GPU가 리소스에 접근할 수 있는 여부를 지정할 수 있음
    * 정점 버퍼, 인덱스 버퍼, 상수 버퍼, 버퍼, 텍스처

 * 리소스 장벽(Resource Barrier)
  - 리소스에 대한 상태 관리를 위한 객체
    다중 쓰레드 처리와 리소스에 대한 사전 처리를 가능하도록 함
  - 리소스에 대한 여러 접근들을 동기화할 필요가 있음을 드라이버에게 통지
    동기화는 하나의 리소스에 대하여 읽기와 쓰기 접근이 동시에 일어날 때 발생
    예) 텍스처 리소스가 SRV와 RTV로 사용될 때
  - 응용 프로그램에서 리소스 상태를 관리할 수 있음
  - 리소스 상태의 종류: D3D12_RESOURCE_STATES(읽기 전용 또는 일기/쓰기 상태)
    어떤 순간에 리소스는 하나의 상태를 가짐
  - 렌더 타겟을 사용하기 위한 상태: D3D12_RESOURCE_STATES_RENDER_TARGET
  - 깊이/스텐실 버퍼 리소스의 초기 상태: D3D12_RESOURCE_STATES_DEPTH_WRITE
  - 후면 버퍼가 프리젠트 될 때 상태: D3D12_RESOURCE_STATES_PRESENT
  - 리소스의 초기 상태

 * 루트 시그니처
  - 쉐이더(GPU함수)가 사용하는 리소스 바인딩에 대한 규약
  - 쉐이더가 요구하는 리소스와 명령 리스트를 연결하기 위한 정보
  - 쉐이더가 프로그램이 요구하는 각 바인딩에 대하여 하나의 루트 시그니처가 필요
   * 그래픽스 루트 시그니처
   * 계산 루트 시그니처


Chapter 6
Direct3D의 그리기 연산

6.1 정점 입력과 배치
 정점의 각 성분으로 무엇을 해야 하는지를 Direct3D에게 알려주는 수단으로 쓰이는 것이 입력 배치 서술 (input layout description)이다.
 
6.2 정점 버퍼
 점점 버퍼를 생성하려면, 버퍼 자원을 서술하는 D3D12_RESOURCE_DESC를 채우고 ID3D12Device::CreateCommittedResource 메서드를
 호출해서 ID3D12Resource 객체를 생성한다.

 정적 기하구조를 그릴 때에는 최적의 성능을 위해 정점 버퍼들을 기본 힙에 넣는다.
 임시 업르도용 버퍼 자원을 생성한다. CPU 메모리에서 GPU 메모리로 자료를 복사하려면 업로드 힙에 자원을 맡겨야 한다.
 업로드 버퍼를 생성한 다음에는 시스템 메모리에 있는 정점 자료를 업로드 버퍼에 복사하고, 그런 다음 업로드 버퍼의 정점 자료를 실제 정점 버퍼로
 복사한다. 기본 버퍼의 자료를 초기화 하려면 항상 임시 업로드 버퍼가 필요하다.
 
 정점 버퍼를 파이프라인에 묶으려면 정점 버퍼 자원을 서술하는 정점 버퍼 뷰를 만들어야 한다. RTV와는 달리, 정점 버퍼 뷰에는 서술자 힙이
 필요하지 않다. 

 정점 버퍼를 생성하고 그에 대한 뷰까지 생성했다면, 이제 정점 버퍼를 파이프라인의 한 입력 슬롯에 묶을 수 있다. 그러면 정점들이 파이프라인의
 입력 조립기 단계로 공급된다.

6.6 상수 버퍼
6.6.1 상수 버퍼의 생성
 상수 버퍼는 쉐이더 프로그램에서 참조하는 자료를 담는 GPU자원의 예이다.
 쉐이더의 매 프레임 변하는 정보들을 


















